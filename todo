todo
1. test timing stack
2. test timing iterators
3. test lexicographical_compare
4. test type_traits
5. test _everyting_ with -Wconversion and valgrind
6. is_constructible and co. (cf. type_traits) for pair conversions
--> need by -Wconversion
7. iterators operators: member or non-member functions ?
8. rb_tree: use _comp to compare keys (otherwise remove it)
9. handle error when _any_ allocate() fails (gotta catch bad_alloc)
10. debug iso_stardard script
11. base_iterator: iterator traits typedefs + comparison operators
12. output_iterator.hpp to .cpp
13. bien penser a tester les valeurs de retour des methodes des containers
14. Faire un namespace test ou mettre tous les typedef, toutes les instances de
    types utiles et les fonctions de log
15. Put custom datatype for output tests in one specific file
16. check compilation flags into makefile
17. 'ft_map.hpp': east const instead of west const
18. compile everything well with c++98
________

maybe
- explicit qualifer upon constructors
- ft::equal (upon all ft datatypes: map, vector, tree, pair, etc.)
- ikos --> utile pour les uninitialized values (valgrind output_stack)
- configure script
- `make all` re-mkdir output folders but not timing ones...
- keep our iterator_traits but forget abour our iterator struct
--> this way, we can use stl algorithms act upon our containers
- make sure that const_iterator = begin() calls the begin() method that returns
const_iterator
--> and not begin() returning iterator then construct const_iterator from it
- add default destructors to be coplien compliant
- say some about when we need or don't need typename after typedef
--> ex: iterators typedefs vs containers typedefs
________

readme
- explain why constructors are explicit
- explain why east const instead of west const
--> the only consistent way to write const (got to read from right-to-left)
- explain the difference between const and non-const begin() and end()
- explain why we choose this implementation for const_iterator
--> explain why the templated solution is better in term of debugging
(i.e. clangd doesnt warn with my solution when 'it = const_it', whereas
it would do with the template solution.)
- say some about the vague subject and why some tests here may be overkill
- explain why map.end() dereferencing segfault: no sentinel node
- make note that insert with hint is just a regular insert
- say some about iterator and reverse iterator relationship
________

iterators
- vector --> random access iterator
- map    --> bidirectional iterator
- base_iterator (iterator traits typedefs + operateurs comparaison)
________

template <bool>
struct ft_static_assert;

template <>
struct ft_static_assert<true>{};
________
https://cppinsights.io/
________
